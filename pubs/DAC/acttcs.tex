\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables


% Copyright
%\setcopyright{none}
\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


\copyrightyear{2019} 
\acmYear{2019} 
\setcopyright{acmlicensed}
%\acmConference[SAC '19]{The 34th ACM/SIGAPP Symposium on Applied Computing}{April 8--12, 2019}{Limassol, Cyprus}
%\acmBooktitle{The 34th ACM/SIGAPP Symposium on Applied Computing (SAC '19), April 8--12, 2019, Limassol, Cyprus}
%\acmPrice{15.00}
%\acmDOI{10.1145/3297280.3297337}
%\acmISBN{978-1-4503-5933-7/19/04}



\acmArticle{4}
\acmPrice{15.00}

% These commands are optional
%\acmBooktitle{Transactions of the ACM Woodstock conference}
%\editor{Jennifer B. Sartor}
%\editor{Theo D'Hondt}
%\editor{Wolfgang De Meuter}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage[inline]{enumitem}

\newcommand{\todo}[1]{{\emph{TODO: #1}}}
\newcommand{\martin}[1]{{\color{blue} Martin: #1}}
\newcommand{\benjamin}[1]{{\color{cyan} #1}}
\newcommand{\isa}[1]{{\color{darkgreen} Isabelle: #1}}


%% uncomment following for final submission
%\renewcommand{\todo}[1]{}
%\renewcommand{\martin}[1]{}
%%\renewcommand{\benjamin}[1]{}
%\renewcommand{\isa}[1]{}

\begin{document}

\title{Actors, Time Stamps, and Determinism \\ for Time-Critical Systems}


\author{Marten Lohstroh}
\orcid{0000-0001-8833-4117}
\email{marten@eecs.berkeley.edu}
% \affiliation{%
% 	\institution{University of California, Berkeley}
% 	%\streetaddress{}
% 	%\postcode{}
% 	%\city{} 
% 	\country{USA} 
% }

\affiliation{%
	\institution{UC Berkeley}
	%\streetaddress{}
	%\postcode{}
	%\city{} 
	\country{USA} 
}

\author{Martin Schoeberl}
\orcid{1234-5678-9012}
\email{masca@dtu.dk}
\affiliation{%
	\institution{TU Denmark}
	%\streetaddress{}
	%\postcode{2800}
	%\city{Lyngby} 
	\country{Denmark} 
}

\author{Andr\'es Goens}
\orcid{}
\email{andres.goens@tu-dresden.de}
\affiliation{%
	\institution{TU Dresden}
	%\streetaddress{}
	%\postcode{}
	%\city{} 
	\country{USA} 
}

\author{Armin Wasicek}
\orcid{}
\email{armin.wasicek@avast.com}
\affiliation{%
	\institution{Avast}
	%\streetaddress{}
	%\postcode{}
	%\city{} 
	\country{USA} 
}

\author{Christopher Gill}
\orcid{}
\email{cdgill@wustl.edu}

\affiliation{%
	\institution{Washington University in St. Louis}
	%\streetaddress{}
	%\postcode{}
	%\city{} 
	\country{USA} 
}

\author{Marjan Sirjani}
\orcid{}
\email{marjan.sirjani@mdh.se}

\affiliation{%
	\institution{M\"alardalen University}
	%\streetaddress{}
	%\postcode{}
	%\city{} 
	\country{Sweden} 
}

\author{Edward A. Lee}
\orcid{0000-0002-5663-0584}
\email{eal@eecs.berkeley.edu}

\affiliation{%
	\institution{UC Berkeley}
	%\streetaddress{}
	%\postcode{}
	%\city{} 
	\country{USA} 
}


\renewcommand{\shortauthors}{E. A. Lee et al.}

\begin{abstract}
Abstract
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%
\begin{CCSXML}
	<ccs2012>
	<concept>
	<concept_id>10010520.10010553.10010562</concept_id>
	<concept_desc>Computer systems organization~Embedded systems</concept_desc>
	<concept_significance>500</concept_significance>
	</concept>
	</ccs2012>  
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}

\keywords{ACM proceedings, \LaTeX, text tagging}%

\ccsdesc[500]{Computer systems organization~Embedded systems}


\keywords{actor, real-time systems, worst-case execution time}

\maketitle 


\section{Introduction}\label{sec:intro}
Since their introduction by Hewitt in the early 70s, the use of actors has proliferated 
in programming languages~\cite{a,b,c}, coordination languages~\cite{d,e}, distributed systems~\cite{f,g}, and simulation engines~\cite{h,i}. %add citations here
Actors have much in common with objects---a paradigm focused on reducing code replication 
by means of inheritance and increasing modularity via data hiding---but unlike %the Object Oriented Programming (OOP) paradigm
objects, actors also provide a model for \emph{concurrency}.
Indeed, in the original formulation of the actor model, each actor is presumed to operate concurrently alongside
other actors that it may exchange messages with, asynchronously. The lack of any guarantees
with respect to the ordering of messages, and the absence of a notion of time, makes this a
very general model, but not a very useful model for the specification of systems in which
timely execution and determinism are important. 

% 

%This paper is organized as follows. Section~\ref{sec:related} surveys related work.
%Section~\ref{sec:hardware} describes the proposed time-predictable branch predictor
%and its different variations. Section~\ref{sec:wcet} presents the associated scope-based
%static WCET analysis technique. Section~\ref{sec:eval} analyzes the worst-case behavior
%of the proposed branch predictor. Finally, Section~\ref{sec:conclusion} concludes
%and gives directions for future work.

\section{Examples}

\begin{figure}
 \centering
 \includegraphics[width=\linewidth]{img/example-1}
 \caption{First example}
 \label{fig:example-1}
\end{figure}

\begin{figure}
 \centering
 \includegraphics[width=\linewidth]{img/example-2}
 \caption{Second example}
 \label{fig:example-2}
\end{figure}

\begin{figure}
 \centering
 \includegraphics[width=\linewidth]{img/example-3}
 \caption{Third example}
 \label{fig:example-3}
\end{figure}

\section{Related Work}
\label{sec:related}

\martin{Is this the first Actor paper? Carl Hewitt; Peter Bishop and Richard Steiger (1973). "A Universal Modular Actor Formalism for Artificial Intelligence". IJCAI.}

\section{Actors}
\label{sec:actor}

Actors communicate via ports. All data exchanged has a timestamp.
An actor does not advance time, the reaction is considered instantaneous.

Reactions of one actor are atomic and are allowed to change state.
Reactions are triggered by available inputs with timestamps at logical
time (or older). When several reactions of an actor are enabled at the
same time, the definition order in LF defines the execution order.

A reaction of an actor can also be released by a trigger. A trigger
can be periodic triggers or a single shot timer.

\martin{We need to check this: Outputs generated by a time triggered
reaction are timestamped. When the system is simulated, the timestamp
is equal to the model time. When the system is used for execution, the logical
time for the release of the reaction is synchronized to wall clock time and therefore
the output message are synchronized to wall clock time.}

\martin{Question: what happens when a reaction depends on two inputs, but
those two inputs have a different logical time?
I assume that the reaction is fired/released when all two inputs have values
(which means logical time is at the younger message)
and a produced output gets the younger timestamp.}

\martin{We have (and maybe support) two options: (1) input is only valid when
the timestamp equals logical time, absent at other times or (2) keeping the value
of an input for future logical time and having a default value for system initialization time.
(in the JS accessors this is the way it is specified, the default value gives the
``keep'' or persistent semantic).}

\subsection{Scribbles on Logical Time}

Time is \emph{logical} time. This logical time be used for simulation and then
we call it model time. We can also use the network of actors for the implementation
of the system. In that case wall clock time is used to timestamp input values
at sensors. Logical time can never advance further than wall clock time.
We have a notion of delay in two places: (1) as a delay actor to break up
feedback loops (2) at actuators to specify that an actuation shall happen before
(or exactly at) the logical time of the input plus the delay.

The scheduler invokes reactions of actors dependent in inputs with timestamps
that are equal (or earlier--can this happen?) at logical time $t_1$.
Logical time cannot advance further than wall clock time $t_w$. If next logical
time $t_2 > t_w$ the scheduler waits till $t_w \ge t_2$.

\subsection{Sporadic Events and Call Backs}

Sporadic events and call backs can trigger a reaction. This reaction is allowed
to observe and also change the state of the actor. Therefore, they are not allowed
to preempt a reaction (reactions are atomic to each other). To enforce this atomicity
a sporadic reaction is executed only between two logical timestamps $t_1$ and $t_2$.
This can be enforced on a C based host by turning off interrupts when executing
a reaction. Interrupts are enabled when all\footnote{\todo{All is a little bit restrictive,
just for state atomicity we would not need to wait for all reaction, just for a single.
But there is another issue that this shall happen only between two timestamps.
I don't recall the details.}}
reactions for timestamp $t_1$ have been executed and disabled again when logical
time is advanced to $t_2$ where all reactions for $t_2$ are executed.


\todo{Describe that the single threaded execution of JavaScript enforces
the restriction of the call back not interrupting the reaction.}

\subsection{More Scribbles}

Delays deserve also the purpose to align events with wall clock time and to
allow execution of reactions in their worst-case execution time (WCET).
The summ of all reaction's WCET from one synchronization point (either
sample of sensors or output of a delay actor) to another synchronization
point (or output of an actuator) has to be less than the delay.

\subsection{Dynamic Actors}

For dynamic systems, e.g., an IoT that keeps running, but in different contexts
(e.g., places), we support dynamic reconfiguration of the network of actors.
This may be well supported when targeting a dynamic language such as JavaScript,
but harder to implement in C.

To support reconfiguration we need a more complete language then the configuration
language LF. Therefore, our first iteration of dynamic reconfiguration is done in the
host language JavaScript. In that case, the host language needs access to actors and
ports. However, we can use scopes to having access to those parts of the framework
only in well defined places.

\subsection{Call of an External Service}

An actor can call an external service that will deliver the result in the future
and use a call back to deliver the result (\martin{Marten likes to use a Future}).
This call back is handled as described above between two model timestamps
and the return value is timestamped with wall clock time.

An actor my implement a timeout mechanism by scheduling a trigger in the future.
{\bf This timeout TO need to be set relative to wall clock time, not logical
time, as logical time will be behind wall clock time.}



\section{Conclusion}
\label{sec:conclusion}


\subsection*{Acknowledgment}

%The work presented in this paper was partially funded by the
%Danish Council for Independent Research \textbar{} Technology and Production Sciences
%under the project PREDICT\footnote{\url{http://predict.compute.dtu.dk/}}
%contract no.~4184-00127A.

% Please do not add any references to msbib.bib.
% They get lost when I 'generate' it again.
\bibliographystyle{ACM-Reference-Format}
\bibliography{msbib} 

\end{document}
